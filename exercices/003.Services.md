# Injection de d√©pendances: Se familiariser avec les services

## But de l'exercice

Se familiariser avec les services

## Pre-Exercice

Cette section est destin√©e aux personnes rencontrant des difficult√©s avec leur projet Symfony. 

Suite √† la demande de certains d'entre vous, je vous ai pr√©parer une liste d'√©tapes afin d'installer votre projet Symfony sans utiliser les commandes `make` afin de vous familiariser avec les commandes `docker`. Lire [Les instructions](000.Installation.md)

Si votre projet Symfony fonctionne correctement, vous pouvez passer directement √† l‚Äô√©tape suivante.

Dans ce document, vous auriez 2 Exercices : 

- Appliquer une promotion sur une commande
- Envoi de mail: Votre site doit envoyer 3 types de mails (newsletter, inscription, erreur syst√®me)


# Exercice 1

## Appliquer une promotion sur une commande

> ‚ö†Ô∏è <span style="color:#F2CB05">Vous devez garder les noms que je vous donne ci-apr√®s car vous devez corriger les conflits des noms comme vu dans le cours</span>


Vous √™tes entrain de d√©velopper un site e-commerce. L'une des parties la plus importante est la gestion du panier. Vous avez d√©cid√© d'√©crire la logique sous forme de services.

#### 1.1 - Gestion de promotions

Le but ici est d‚Äô√©crire un syst√®me de services qui cohabitent et permettent de g√©rer l‚Äôapplication des promotions sur un panier.

Comme vous aviez d√©j√† mentionn√© avoir travaill√© avec le **TDD** (Test Driven Development ‚Äì D√©veloppement guid√© par les tests), nous allons essayer cette technique ici puisque nous n‚Äôavons pas de moyen de v√©rifier que les services sont corrects (pas de formulaires, pas de contr√¥leurs...).

- Installer le pack des tests unitaires (phpunit) en lancant la commande: `composer require --dev symfony/test-pack` (√† l'int√©rieur du container *php*)

- Vous devez cr√©er un test unitaire pour tester les cas suivants: 

**Promotions**

1) `testComputeRegularPromotion` : ce test v√©rifie le calcul d‚Äôune promotion en appliquant une promotion r√©guli√®re.

Si une promotion r√©guliaire est de *-200,00 dhs* sur un montant total de *1500,00 dhs*, le montant final net doit √™tre *1300,00 dhs*

2) `testComputePercentagePromotion` : ce test v√©rifie le calcul d‚Äôune promotion en appliquant une promotion en pourcentage.

Si une promotion est de *-20%* sur un montant total de *1500,00 dhs*, le montant final net doit √™tre *1500,00 - 20% = 1200,00 dhs* car 20% de 1500,00 = 300dhs => 1500 - 300 = *1200, 00 dhs*

le test unitaire final doit √™tre: 

```php
// tests/App/Cart/Promotion/PromotionTest.php

<?php

namespace App\Tests\App\Cart\Promotion;

use App\Cart\Promotion\Promotion;
use App\DTO\Cart;
use App\DTO\PercentagePromotion;
use App\DTO\RegularPromotion;
use PHPUnit\Framework\TestCase;

class PromotionTest extends TestCase
{
    public function testComputeRegularPromotion(): void
    {
        $promotionManager = new Promotion();

        $regularPromotion = new RegularPromotion(200.00);
        $cart = new Cart(1500.00);

        $cart = $promotionManager->apply(promotion: $regularPromotion, cart: $cart);

        $this->assertEquals(1300.00, $cart->getTotalNetPrice());
    }

    public function testComputePercentagePromotion(): void
    {
        $promotionManager = new Promotion();

        $regularPromotion = new PercentagePromotion(20.00);
        $cart = new Cart(1500.00);

        $cart = $promotionManager->apply(promotion: $regularPromotion, cart: $cart);

        $this->assertEquals(1200.00, $cart->getTotalNetPrice());
    }
}

```

‚ö†Ô∏è  <span style="color:#F2CB05">you can write other unit tests.</span>


En Symfony, pour lancer les tests uniataire, il faut lancer la commande `bin/phpunit tests/` ou  pour un test pr√©cis `bin/phpunit tests/App/Cart/Promotion/PromotionTest.php`

Vous devez arriver au resultat suivant : 

![alt text](image-26.png)

#### 1.2 - D√©veloppement du code production  (Logique pour corriger les tests unitaires)

- Cr√©er deux classes DTO dans **src/DTO** : *RegularPromotion* et *PercentagePromotion*, qui repr√©sentent respectivement une promotion r√©guli√®re (prix final = prix initial ‚àí montant de la promotion) et une promotion avec pourcentage (prix final = prix initial ‚àí % de r√©duction).

![alt text](image-24.png)

> ‚ùì <span style="color:#FF5F5D">Selon vous ? pourquoi nous avons une classe abstraite `Promotion` ici ? et pour quelle raison nous avons la m√©thode `compute()` abstraite ?</span>


- Afin de s√©parer les logiques, vous avez d√©cider d'organiser vos services de la mani√®re suivante :

    - Application de la promotion: G√©r√©e par le service `src/Cart/Promotion/Promotion.php`
    - Persister (sauvegarder) le panier en base de donn√©es, session, API ... : il s'agit du service `src/Cart/Persist/CartPersister.php`
    - Gestion du Panier = liaison entre le Persister et les Promotions. Il s'agit de `src/Cart/Handler/CartHandler.php`

![alt text](image-25.png)

*Rappel* : si vous souhaitez repr√©senter l‚Äôinjection de d√©pendances, vous utilisez la notation *<< uses >>*.

> ‚ùì <span style="color:#FF5F5D">Comment PHP va r√©agir dans le service `src/Cart/Promotion/Promotion.php` puisque la m√©thode `apply()` a besoin de `src/DTO/Promotion.php` ? Comment vous allez corriger ce conflit ?</span>


‚úÖ <span style="color: #04BF8A">Vous pouvez toujours travailler avec les contr√¥leurs si le TDD ne vous semble pas faisable.</span>

## Proposition de code 

Ci‚Äëdessous figurent des propositions de classes et de logiques, mais vous pouvez les modifier, les adapter ou les d√©velopper si vous estimez que cela est n√©cessaire.

### DTOs

- `src/DTO/Cart.php`

    ```php

    <?php

    declare(strict_types=1);

    namespace App\DTO;

    class Cart
    {
        private array $promotions;

        private readonly float $totalRawPrice;

        private float $totalNetPrice = 0.00;

        public function __construct(float $totalRawPrice)
        {
            $this->promotions = [];
            $this->totalRawPrice = $totalRawPrice;
        }

        public function getTotalRawPrice(): float
        {
            return $this->totalRawPrice;
        }

        public function appy(Promotion $promotion): static
        {
            $netPrice = $this->getTotalRawPrice();

            $netPrice = $promotion->compute($netPrice);
            $this->setTotalNetPrice($netPrice);

            // add the promotion to the set of promotions applied to this cart
            $this->promotions[] = $promotion;

            return $this;
        }

        public function getTotalNetPrice(): float
        {
            return $this->totalNetPrice;
        }

        public function setTotalNetPrice(float $totalNetPrice): void
        {
            $this->totalNetPrice = $totalNetPrice;
        }
    }

    ``` 

- `src/DTO/Promotion.php`

    ```php
    <?php

    declare(strict_types=1);

    namespace App\DTO;

    abstract class Promotion
    {
        public function __construct(protected float $value)
        {

        }

        abstract public function compute(float $initialPrice): float;
    }

    ```

- `src/DTO/PercentagePromotion.php`

    ```php
    <?php

    declare(strict_types=1);

    namespace App\DTO;

    class PercentagePromotion extends Promotion
    {
        public function compute(float $initialPrice): float
        {
            return $initialPrice * (1 - 0.01 * $this->value);
        }
    }

    ```

- `src/DTO/RegularPromotion.php`

    ```php
    <?php

    declare(strict_types=1);

    namespace App\DTO;

    class RegularPromotion extends Promotion
    {
        public function compute(float $initialPrice): float
        {
            return $initialPrice - $this->value;
        }
    }

    ```

‚ÑπÔ∏è <span style="color: #0897B4">Vous pouvez par exemple ici mettre des validations: si la valeur de value est > √† la valeur initiale, ne pas appliquer la promotion. Une valeur n√©gative de la promotion est √©galement non acceptable.</span>

### Les services

- `srcsrc/Cart/Promotion/Promotion.php`

    ```php
    <?php

    declare(strict_types=1);

    namespace App\Cart\Promotion;

    use App\DTO\Cart;
    use App\DTO\Promotion as PromotionDTO;

    final class Promotion
    {
        public function apply(PromotionDTO $promotion, Cart $cart): Cart
        {
            $cart->appy($promotion);
            // ... you may also add some logic here if you want

            return $cart;
        }

        // ... add more methods related to promotion if needed
    }

    ```

- `src/Cart/Persist/CartPersister.php`

    ```php
    <?php

    declare(strict_types=1);

    namespace App\Cart\Persist;

    use App\DTO\Cart;
    use App\DTO\Promotion as PromotionDTO;

    class CartPersister
    {
        /**
         * @param Cart $cart
         * @param PromotionDTO[] $promotions
         *
         * @return bool
         */
        public function persist(Cart $cart, array $promotions = []): bool
        {
            // do some logic like persisting the cart to the database

            return true;
        }

        // ... add more methods (probably private) if you want
    }

    ```

- `src/Cart/Handler/CartHandler.php`

    ```php
    <?php

    declare(strict_types=1);

    namespace App\Cart\Handler;

    use App\DTO\Promotion as PromotionDTO;
    use App\Cart\Persist\CartPersister;
    use App\Cart\Promotion\Promotion;
    use App\DTO\Cart;

    final class CartHandler
    {
        // Inject the dependancies here
        public function __construct(
            private CartPersister $cartPersister,
            private Promotion $promotionApplier,
        ) {
        }

        /**
         * @param Cart $cart
         * @param PromotionDTO[] $promotions
         *
         * @return bool
         */
        public function handle(Cart $cart, array $promotions = []): bool
        {
            // Make sure that all the promotions are **Instances of ** Promotion
            if (!\array_all($promotions, fn ($item) => $item instanceof PromotionDTO)) {
                return false;
            }

            // Apply the promotions before persisting to the database
            foreach ($promotions as $promotion) {
                $this->promotionApplier->apply($promotion, $cart);
            }

            // ... we can imagine here whatever logic that might returns false or something
            // here I am just testing on the prices to show you some cases where the `hande()` can return false 
            // you can do any handling logic here
            if ($cart->getTotalRawPrice() <= 0 || $cart->getTotalNetPrice() <= 0) {
                return false;
            }


            return $this->cartPersister->persist($cart);;
        }
    }

    ```


## Qu'est ce que vous avez appris : 

1. Le service `CartHandler` a besoin de 2 services `Promotion` et `CartPersister`. 
2. Nous avons utilis√© l'injection de d√©pendances ici pour injecter les services `Promotion` et `CartPersister` dans `CartHandler`. 
3.  <span style="color:#FF5F5D">Quel est le responsable de cette injection / l'instanciation de ces services alors? </span>
4. Nous n'avons rien configur√©, <span style="color:#FF5F5D"> comment ce fait-il que Symfony a pu savoir quelle instance √† injecter? </span>


# Exercice 2

## Envoi de mail: Votre site doit envoyer 3 types de mails (newsletter, inscription, erreur syst√®me)

Nous sommes d‚Äôaccord pour envoyer des emails dans les cas suivants :

- Apr√®s une inscription

- En cas d‚Äôerreur syst√®me

- Lors d‚Äôun abonnement √† une newsletter

Pour chaque cas, nous souhaitons que l‚Äô√©metteur de l‚Äôemail (adresse from) soit diff√©rent: 

- Apr√®s une inscription : le mail envoy√© par *register@eheio.ma*

- En cas d‚Äôerreur syst√®me : le mail envoy√© par *alert@eheio.ma*

- Lors d‚Äôun abonnement √† une newsletter : *newsletter@eheio.ma*

Nous sommes √©galement d‚Äôaccord sur le fait que l‚Äôenvoi d‚Äôemails dans ces cas est similaire et qu‚Äôil est judicieux de centraliser ce traitement.

Pour cela, nous avons d√©cid√© de cr√©er un service `src/Service/Mailer/Mailer.php` o√π nous allons centraliser le code responsable de l‚Äôenvoi des emails.

1. Ecrire un service dans `src/Service/Mailer/Mailer.php` permettant d'envoyer un mail via Symfony:

2. En Symfony, pour envoyer un mail (via la couche r√©seau = bas niveau), il faut injecter le service de Symfony disponible en utilisant `Symfony\Component\Mailer\MailerInterface` comme type d'argument. Voici un exemple d'implementation simple: 


    ```php
    <?php

    declare(strict_types=1);

    namespace App\Service\Mailer;

    use Symfony\Component\Mailer\MailerInterface;
    use Symfony\Component\Mime\Email;

    class Mailer
    {
        private MailerInterface $mailer;

        public function __construct(MailerInterface $mailer)
        {
            $this->mailer = $mailer;
        }

        public function send(string $from, string $to, string $subject, string $body): void
        {
            $message = $this->doCreateMessage($from, $to, $subject, $body);

            $this->mailer->send($message);
        }

        public function sendWithAttachment(string $from, string $to, string $subject, string $body, array $attachments): void
        {
            $message = $this->doCreateMessage($from, $to, $subject, $body);

            foreach ($attachments as $attachment) {
                $message->attachFromPath($attachment);
            }

            $this->mailer->send($message);
        }

        private function doCreateMessage(string $from, string $to, string $subject, string $body): Email
        {
            return (new Email())->from($from)
                ->to($to)
                ->subject($subject)
                ->html($body);
        }
    }

    ```

Ce service dispose de 2 m√©thodes: 

- *send()* : permet d'envoyer un mail simple.
- *sendWithAttachment()* : permet d'envoyer un mail avec des pi√®ces jointes.

3. Cr√©er un contr√¥leur `src/Controller/NewsletterController.php`. Ce contr√¥leur jouera le r√¥le avec la commande 

    ```
    php bin/console make:controller Newsletter
    ```

4. Nous avons donc pour l'instant la route suivante: 
    ```php
    #[Route('/newsletter', name: 'app_newsletter')]
    public function index(): Response
    {
        return $this->render('newsletter/index.html.twig');
    }

    ```

    et donc accessible avec [http://localhost/newsletter](http://localhost/newsletter)

5. Dans la template `templates/newsletter/index.html.twig`, mettez un formulaire en POST permettant de soumettre les donn√©es √† [http://localhost/register](http://localhost/register)

    Exemple d'implementation: 

    ```twig
    {% extends 'base.html.twig' %}

    {% block title %}Hello NewsletterController!{% endblock %}

    {% block body %}
    <form method="post" action="{{ url('app.newsletter.register') }}">
        <input name="email" type="email"/>
        <button type="submit">S'inscrire</button>
    </form>
    {% endblock %}
    ```

    Rappelez-vous : en Twig, la fonction `url()` permet de g√©n√©rer une URL absolue √† partir du nom de la route (dans l'exemple `'app.newsletter.register'`)

6. Cr√©er une action accessible uniquement en **POST** avec comme nom `name: 'app.newsletter.register'` et accessible uniquement en POST `methods: ['POST']` et comme URL `path: '/register'`. 

    ```php
    #[Route(path: '/register', name: 'app.newsletter.register', methods: ['POST'])]
        public function registerNewsletter(): Response 
        {
            // ...
        }
    ```

### DTO

7. Pour avoir un code correct et respectant le clean code, nous avons d√©cid√© de cr√©er un objet (DTO) `src/DTO/Newsletter.php`. Cette classe dispose d'un seul attribut `public string $email;`

    ```php
    <?php

    declare(strict_types=1);

    namespace App\DTO;

    class Newsletter
    {
        public string $email;
    }

    ```

    üì¢ Vous vous souvenez de `#[MapRequestPayload]`‚ÄØ? C‚Äôest l‚Äôoccasion de l‚Äôutiliser. Nous souhaitons √©tablir un mappage entre le formulaire et l‚Äôobjet src/DTO/Newsletter.php. Rappelez-vous, il est fortement recommand√© d‚Äôutiliser des objets plut√¥t que des variables ou des tableaux. Cela permet de d√©finir un contrat d‚Äôinterfa√ßage et de produire un code concis.

    Changeons donc dans `src/Controller/NewsletterController.php`

    ```php
        use Symfony\Component\HttpKernel\Attribute\MapRequestPayload;


        #[Route(path: '/register', name: 'app.newsletter.register', methods: ['POST'])]
    public function registerNewsletter(
        #[MapRequestPayload] Newsletter $newsletter,
    ): Response {
        // ...
    }
    ```

8. Envoyer le mail :

    L'envoi de mail consiste √† injecter notre service que nous avons cr√©√© ci-dessus. 

    Pour cela, nous allons utiliser le constructeur de `src/Controller/NewsletterController.php` pour injecter notre service: 

    ```php
    <?php

    declare(strict_types=1);

    namespace App\Controller;

    use App\DTO\Newsletter;
    use App\Service\Mailer\Mailer;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\MapRequestPayload;
    use Symfony\Component\Routing\Attribute\Route;

    final class NewsletterController extends AbstractController
    {
        private Mailer $mailer;

        public function __construct(Mailer $mailer)
        {
            $this->mailer = $mailer;
        }

        #[Route('/newsletter', name: 'app_newsletter')]
        public function index(): Response
        {
            return $this->render('newsletter/index.html.twig');
        }

        #[Route(path: '/register', name: 'app.newsletter.register', methods: ['POST'])]
        public function registerNewsletter(
            #[MapRequestPayload] Newsletter $newsletter,
        ): Response {
            $this->mailer->send(
                to: $newsletter->email,
                from: 'newsletter@eheio.ma',
                body: 'A new subscriber has been added to the newsletter.',
                subject: 'New subscriber to the newsletter',
            );

            return $this->redirectToRoute(...);
        }
    }
    ```

    Remarque: 

    si vous rencontrez l'erreur

    ![alt text](image-27.png)

    vous devez supprimer la ligne `Symfony\Component\Mailer\Messenger\SendEmailMessage: async` dans le ficheir `config/packages/messenger.yaml`. Nous pouvons en parler dans le cours si vous le souhaitez.

    Pour v√©rifier si le mail est envoy√©, vous pouvez v√©rifier sur le profiler [http://localhost/_profiler/empty/search/results?limit=10](http://localhost/_profiler/empty/search/results?limit=10) 

    ![alt text](image-28.png)

    Dans la colonne **token**, cliquez sur l'identifiant ici *12d118* (l'identifiant peut √™tre different chez vous), puis depuis le menu de gauche, s√©lectionnez *Emails* 

    ![alt text](image-29.png)

9. OK . Maintenant, voici ce qu'on a d√©cid√© de faire: 
   
   Au lieu de √† chaque fois sp√©cifier *register@eheio.ma*, *alert@eheio.ma* ou *newsletter@eheio.ma*, nous avons d√©cid√© de cr√©er pour chaque adresse email, un service d√©di√© mais pour la m√™me classe (`src/Service/Mailer/Mailer.php`). Donc: 

   9.1. Mettre `string $from` comme argument dans le constructeur du service `src/Service/Mailer/Mailer.php` au lieu de la mettre en argument de *send()*

   ```php
    class Mailer
    {
        private MailerInterface $mailer;
        private string $fromAddress;

        public function __construct(MailerInterface $mailer, string $fromAddress)
        {
            $this->mailer = $mailer;
            $this->fromAddress = $fromAddress;
        }

        public function send(string $from, string $to, string $subject, string $body): void
        {
            $message = $this->doCreateMessage(
                $this->fromAddress,
                $to,
                $subject, 
                $body,
            );

            $this->mailer->send($message);
        }

        // ...
    }

    ```

   9.2. Dans `config/services.yaml`, nous allons configurer 3 services (1 service par adresse email).

    ```yaml
    services:

        _defaults:
            autowire: true
            autoconfigure: true 

        App\:
            resource: '../src/'

        app.mailer.newsletter:
            class: App\Service\Mailer\Mailer
            arguments:
                $fromAddress: 'newsletter@eheio.ma'
                
        app.mailer.register:
            class: App\Service\Mailer\Mailer
            arguments:
                $fromAddress: 'register@eheio.ma'
                
        app.mailer.alert:
            class: App\Service\Mailer\Mailer
            arguments:
                $fromAddress: 'alert@eheio.ma'

    ```

    Si vous retestez votre code vous devez avoir l'erreur suivante : 

    ![alt text](image-30.png)


    üîî <span style="color: #F3B562">Cherchez pourquoi nous avons cette erreur et ce qui la cause.</span>

---

### üéÅ Bonus: 

Si vous souhaitez impl√©menter un serveur SMTP en local avec Docker, ajoutez les lignes suivantes dans `compose.yaml` si cela n‚Äôa pas encore √©t√© fait.

```yaml
    services:
        # ...

        mailcatcher:
            networks:
                - internal_network
            image: yappabe/mailcatcher
            ports:
                - 1025:1025
                - 1080:1080
        # ...
```

Pour acc√©der √† l'interface graphique: [http://localhost:1080](http://localhost:1080)

Pour configurer votre projet √† utiliser ce container (si vous ne souhaitez pas utiliser le profiler ou si vous voulez l'utiliser avec un autre microservice), utiliser le DSN suivant : `smtp://mailcatcher:1025`

En Symfony, mettez cette valeur dans `.env` : *MAILER_DSN=smtp://mailcatcher:1025*

Soumettez votre formulaire: 

![alt text](image-31.png)